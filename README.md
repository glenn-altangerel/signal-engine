

For English version, please see `README.en.md` of this repo.
英語版については、本リポジトリの `README.en.md` を参照してください。


<a id="0"></a>
# はじめに

以下を実行するだけで、このリポジトリの動作が分かります。

**リポジトリ内でターミナルを1つ開き**、次のコマンドを（上から順に）実行してください：

```bash
python dummy_data_producer/dummy_data.py
python dummy_data_producer/dummy_data_realtime.py
```

> 2つ目のコマンドは `Ctrl C` で停止するまで実行され続けますが、**まだ停止しないでください。**

そのまま実行し続けた状態で、**別のターミナルをもう1つ**リポジトリ内で開き、以下をターミナルに貼り付けて Enter を押してください。

```bash
python trade/main.py
```

すると、次のように見えます。

* `data/` では、日付が最新の CSV に対して、**5 秒ごと（デモ用）**に新しいバーが追記されます。バーのタイムスタンプは、ローソク足の時間足（例：1 時間足）ごとに進みます。
* `signals/` では、日付が最新の CSV に対して、新しいバーのデータが到着すると直ちにシグナル（`buy` / `sell` / `hold`）が生成されます
* データおよびシグナルはいずれもプレースホルダーとして用意されているため、ランダムに生成されています。

詳細については、この先をお読みください。


- [はじめに](#0)
- [目的](#1)
- [各パートの役割](#2)
  - [概要](#2.0)
    - [バックテストモード](#2.0.0)
    - [リアルタイム・シグナル生成モード](#2.0.1)
  - [ダミーデータ](#2.1)
    - [ジェネレーターの使い方](#2.1.0)
    - [結果](#2.1.1)
  - [シグナル生成部分](#2.2)
    - [構成要素と各要素の役割](#2.2.0)
      - [バックテストおよびリアルタイム・シグナル生成の両方で使用されるファイル](#2.2.0.0)
      - [バックテストで使用されるファイル](#2.2.0.1)
      - [リアルタイム・シグナル生成で使用されるファイル](#2.2.0.2)
    - [結果](#2.2.1)
- [詳細な使用手順](#3)
  - [STEP 1：バックテストをシミュレートする](#3.0)
  - [STEP 2：リアルタイム・シグナル生成をシミュレートする](#3.1)
  - [STEP 3：自分のデータを組み込む](#3.2)
  - [STEP 4：自分のストラテジーを実装する](#3.3)
- [付録：引数の意味](#4)
- [制限事項と範囲](#5)
  - [このフレームワークが行うこと](#5.0)
  - [このフレームワークが提供しないもの](#5.1)
  - [概念上の境界](#5.2)
    - [バックテストのスコープ](#5.2.0)
    - [シグナルの意味](#5.2.1)
  - [機能上の制限（MVP スコープ）](#5.3)

<a id="1"></a>
# 目的

このフレームワークは、OHLCV データから **シグナル生成** を行うためのインフラを、以下の 2 つのモードで提供します。

* **バックテストモード**：過去データの各ウィンドウごとに 1 つのシグナルを生成
* **リアルタイムモード**：新しいバーが確定した直後に 1 つのシグナルを生成

生成されるシグナル（`buy`、`sell`、`hold`）は **あくまでプレースホルダー** です。
実際の戦略ロジックは、利用者自身で実装することを前提としています。


<a id="2"></a>
# 各パートの役割
<a id="2.0"></a>
## 概要
<a id="2.0.0"></a>
### バックテストモード

```text
過去データ（CSV ファイル）
data/asset_name/YYYY-MM-DD.csv
        │
        │  （時系列順に読み込み）
        ▼
+--------------------+
|   backtester.py    |
|--------------------|
| - 全データを読み込み  |
| - スライディング     |
|   ウィンドウを構築   |
+--------------------+
        │
        │  （固定長ウィンドウを 1 つずつ）
        ▼
+--------------------+
|   strategy.py      |
|--------------------|
|--------------------|
| - ウィンドウを受信   |
| - 最終バーの        |
|   タイムステップで   |
|   シグナルを計算     |
+--------------------+
        │
        │  （シグナル: buy / sell / hold）
        ▼
生成されたシグナル（CSV ファイルに保存）
signals/asset_name/YYYY-MM-DD.csv
```

<a id="2.0.1"></a>
### リアルタイム・シグナル生成モード

```text
ライブデータフィード（API またはダミージェネレーター）
        │
        │  （新しいバーを追加）
        ▼
data/asset_name/YYYY-MM-DD.csv
        │
        │  （更新をウォッチャーが監視）
        ▼
+--------------------+
|    watcher.py      |
|--------------------|
| - CSV を監視        |
| - 新しいバーを検出    |
+--------------------+
        │
        │  （通知）
        ▼
+--------------------+
|    trader.py       |
|--------------------|
| - 直近の            |
|   ウィンドウを読み込み |
+--------------------+
        │
        │  （固定長ウィンドウを 1 つずつ）
        ▼
+--------------------+
|   strategy.py      |
|--------------------|
| - ウィンドウを受信    |
| - 新しいバーの        |
|   タイムステップで     |
|   シグナルを計算      |
+--------------------+
        │
        │  （シグナル: buy / sell / hold）
        ▼
生成されたシグナル（CSV ファイルに保存）
signals/asset_name/YYYY-MM-DD.csv
```


<a id="2.1"></a>
## ダミーデータ

この部分では、`data/` フォルダにランダムなデータを生成します。
これは、フレームワークが対応している **データファイルの構造とフォーマットを示すためだけのもの** であり、実際のデータを生成する目的ではありません。

実際のトレーディング用途では、この部分を **自身の API コード** に置き換える必要があります。

その際、フレームワークが正しく動作するよう、**同一のデータファイル構造およびフォーマット** でデータを出力する必要があります（詳細は下記参照）。

```text
dummy_data_producer/
├─ dummy_data.py
└─ dummy_data_realtime.py
```

* `dummy_data.py`：バックテスト用の完結したデータセットを模擬するために、過去の OHLCV データを生成し、CSV ファイルに書き出します。
* `dummy_data_realtime.py`：
  * `dummy_data.py` によって生成された過去の OHLCV データを読み込み、バーの時間間隔および最新バーのタイムスタンプを推定します。
  * 推定された時間間隔に従い、最新のタイムスタンプから開始して、新しい OHLCV バーを継続的に CSV ファイルへ追加し、リアルタイム処理向けのライブデータフィードを模擬します。

<a id="2.1.0"></a>
### ジェネレーターの使い方

1. **ステップ 1**：リポジトリ内で、以下を実行してデータを生成します。
   ```bash
   python dummy_data_producer/dummy_data.py
   ```
   バックテスト用途であれば、ステップ 1 だけで十分です。

2. **ステップ 2**：次に、以下を実行して、最新の OHLCV バーを WebSocket API のように継続的に自動追加します。
   ```bash
   python dummy_data_producer/dummy_data_realtime.py
   ```
   例えば、2025-12-08 の時点で、すでに `…, 20:00–21:00, 20:00–21:00, 21:00–22:00` の OHLCV バーデータが存在している場合、`dummy_data_realtime.py` は次のように動作します。
   * 22:00–23:00 のバーデータを追加
   * 5 秒待機
   * 23:00–00:00 のバーデータを追加
   * 5 秒待機
   * 00:00–01:00 のバーデータを追加（ここから日付は 2025-12-09 となり、データは新しい CSV ファイルに保存されます）
   * 5 秒待機
   * 01:00–02:00 のバーデータを追加
   * …
   * `Ctrl+C` を押すまで、この処理を継続します。

   > *`dummy_data.py` で設定された間隔（分足・時間足・日足）に関わらず、`dummy_data_realtime.py` は動作確認を容易にするため、5 秒ごとに新しいバーを追加します。実際のトレーディング用途に切り替えた場合は、フレームワークが API の更新頻度に自動的に適応します。*


<a id="2.1.1"></a>
### 結果

> ここでの `asset_name` はプレースホルダーです。ご自身のシンボル名に置き換え、`main.py` 内の引数 `data_dir` もそれに合わせて一貫させてください。詳細は後述します。
> フォルダ構成は将来の拡張を見据えてすでにアセット単位になっていますが、MVP では 1 回につき 1 アセットのみを扱います。

```text
data/
└─ asset_name/
    ├─ 2025-12-01.csv
    ├─ 2025-12-02.csv
    ├─ 2025-12-03.csv
    ├─ 2025-12-04.csv
    ├─ ...
```

各ファイルの中には次の内容が含まれています。

| open_time                 | close_time                | open   | high   | low   | close  | volume  |
| ------------------------- | ------------------------- | ------ | ------ | ----- | ------ | ------- |
| 2025-12-01T00:00:00+00:00 | 2025-12-01T01:00:00+00:00 | 99.98  | 100.16 | 99.84 | 100.06 | 629.43  |
| 2025-12-01T01:00:00+00:00 | 2025-12-01T02:00:00+00:00 | 100.04 | 100.05 | 99.78 | 99.85  | 705.37  |
| 2025-12-01T02:00:00+00:00 | 2025-12-01T03:00:00+00:00 | 99.88  | 100.05 | 99.86 | 100.00 | 1150.18 |
| … | … | … | … | … | … | … |


<a id="2.2"></a>
## シグナル生成部分
<a id="2.2.0"></a>
### 構成要素と各要素の役割

```text
trade/
├─ backtest/
│  └─ backtester.py
│
├─ realtime_trader/
│  ├─ trader.py
│  └─ watcher.py
│
├─ strategy/
│  └─ strategy.py
│
└─ main.py
```

> 名前とは異なり、`trader.py` はウィンドウの読み込みとシグナルの書き込みを制御するだけであり、注文の発注は行いません。

<a id="2.2.0.0"></a>
#### バックテストおよびリアルタイム・シグナル生成の両方で使用されるファイル

* **`main.py`**：
  * 以下を定義します。
    * バックテストを行うか、リアルタイム・シグナル生成を行うか
    * ストラテジーに関する各種パラメータ（例）：
      * 各時点のシグナル生成において、過去何本分のバーを参照するか
      * CSV の更新をどれくらいの頻度で監視するか（0.5 秒、1 秒、2 秒など）
      * ユーザー自身で定義できるその他のストラテジー用パラメータ（自分で追加する必要があります）
  * バックテスター、またはリアルタイム・トレーダーを実行します。

* **`strategy.py`**：
  * バックテストモード・リアルタイム・シグナル生成モードのいずれであっても、「直近の複数のバーからなる固定長ウィンドウ」が与えられます。
  * そのウィンドウ内の OHLCV データに基づき、ウィンドウ内の最後のバーのタイムスタンプに対応するシグナル、すなわち新しいバーを確認した直後に取るべきアクション（`buy`、`sell`、`hold`）を生成します。

<a id="2.2.0.1"></a>
#### バックテストで使用されるファイル
**バックテスト**を行う場合（`main.py` で引数 `work_mode` を `backtest` に設定した場合）：
* **`backtester.py`**：
    * `data/` フォルダ内のすべてのデータを読み込み、データ上でウィンドウをスライドさせながら、各ウィンドウを `strategy.py` に渡してシグナルを生成し、その結果を `signals/` に保存します。


<a id="2.2.0.2"></a>
#### リアルタイム・シグナル生成で使用されるファイル

**リアルタイム・シグナル生成**を行う場合（`main.py` で引数 `work_mode` を `realtime` に設定した場合）：
* **`watcher.py`**：
    * `data/asset_name` 配下の最新日付の CSV に新しい OHLCV バーが追加されたことを検知すると、`trader.py` に通知します。
* **`trader.py`**：
    * watcher から通知を受け取ると、データ内の最新のウィンドウを特定し、そのウィンドウを `strategy.py` に渡して新しいシグナルを取得します。
    * 生成されたシグナルを、`signals/asset_name` 配下の対応する CSV に保存します。
    * 注記：リアルタイム・モードはリアルタイムのシグナル生成を**シミュレート**するものであり、注文の発注は行いません。

> ウィンドウは時間的な連続性ではなく、行数（バー数）に基づいて構築されます。週末や祝日などによるデータの欠損がある場合、ウィンドウは単により長い暦期間にまたがることになります。こうしたギャップへの対応や検証は、要件に応じて各ストラテジー側で明示的に実装してください。

<a id="2.2.1"></a>
### 結果

```text
signals/
└─ asset_name/
    ├─ 2025-12-03.csv
    ├─ 2025-12-04.csv
    ├─ ...
```


<a id="3"></a>
# 詳細な使用手順
<a id="3.0"></a>
## STEP 1：バックテストをシミュレートする
1. `trade/main.py` を開きます。
2. 次の行を
   ```python
   parser.add_argument("--work_mode", type=str, default="realtime", choices=["backtest", "realtime"], help='options: ["backtest","realtime"]')
   ```

   以下のように変更します。

   ```python
   parser.add_argument("--work_mode", type=str, default="backtest", choices=["backtest", "realtime"], help='options: ["backtest","realtime"]')
   ```
3. ターミナルで次を実行し、過去データ（ダミー）を生成します。
   ```bash
   python dummy_data_producer/dummy_data.py
   ```
4. ターミナルで次を実行して、バックテストを開始します。
   ```bash
   python trade/main.py
   ```
5. 生成されたシグナルを `signals/` フォルダで確認します。


<a id="3.1"></a>
## STEP 2：リアルタイム・シグナル生成をシミュレートする
1. `trade/main.py` を開き、引数 `work_mode` が `realtime` に設定されていることを確認します。
2. ターミナルで次を実行し、過去データ（ダミー）を生成します。
   ```bash
   python dummy_data_producer/dummy_data.py
   ```
3. ターミナルで次を実行し、WebSocket API のようにリアルタイムのデータフィードを継続的に生成します。
   ```bash
   python dummy_data_producer/dummy_data_realtime.py
   ```
4. リアルタイム・シグナル生成を開始するには、**別のターミナルを開き**（重要：リアルタイムのデータフィードは停止しないでください）、次を実行します。
    ```bash
    python trade/main.py
    ```
5. `data/` と `signals/` の両方の更新を確認します。デフォルトでは、バーが時間足であっても分足であっても、フレームワークは 5 秒ごとに新しいバーと、それに対応するシグナルを生成します。
   
   *ここでの 5 秒はデモ用です。実運用では、例えば WebSocket API が 1 時間ごとに新しいバーのデータを配信する場合、トレーダーも 1 時間ごとにシグナルを生成します。新しいバーのデータがいつ入力されるかに依存します。*


<a id="3.2"></a>
## STEP 3：自分のデータを組み込む

ここでは、ランダムデータ生成器を自分の API データに置き換えます。

API コードから取得するデータは、次の形式に従ってください。

* 1 つのアセットに関するすべてのデータは、`data/asset_name` フォルダ配下に配置します。`"asset_name"` は実際のアセット名に置き換え、`main.py` の引数 `data_dir` もそれに合わせて更新してください。
* 各 CSV ファイルには、時間足の種類（秒足、分足、5 分足、時間足など）に関わらず、**1 日分のデータのみ**を含めます。
* CSV ファイル名は `2025-12-01.csv` のような日付形式にしてください。
* 各 CSV ファイル内のヘッダーは、`open_time`, `close_time`, `open`, `high`, `low`, `close`, `volume` とします。
* このルールは必須です。誤りを避けるため、タイムスタンプには必ずタイムゾーンオフセット（例：+00:00）を付けてください。`+00:00` は UTC からのタイムゾーンオフセットを明示的に指定するものです。これにより、タイムゾーン間の混乱を防ぎ、タイムスタンプを明確にします。例：
    * `+00:00` = UTC（協定世界時）
    * `+09:00` = UTC+9（日本標準時、JST）
    * `+01:00` = UTC+1（フランス冬時間、中央ヨーロッパ時間、CET）
    * `+02:00` = UTC+2（フランス夏時間、中央ヨーロッパ夏時間、CEST）

    > 私は世界のどこにいても、`+00:00`（UTC）で作業することに慣れています。

```text
data/
└─ asset_name/
    ├─ 2025-12-01.csv
    ├─ 2025-12-02.csv
    ├─ 2025-12-03.csv
    ├─ 2025-12-04.csv
    ├─ ...
```

各ファイルの中には次の内容があります

| open_time                 | close_time                | open   | high   | low   | close  | volume  |
| ------------------------- | ------------------------- | ------ | ------ | ----- | ------ | ------- |
| 2025-12-01T00:00:00+00:00 | 2025-12-01T01:00:00+00:00 | 99.98  | 100.16 | 99.84 | 100.06 | 629.43  |
| 2025-12-01T01:00:00+00:00 | 2025-12-01T02:00:00+00:00 | 100.04 | 100.05 | 99.78 | 99.85  | 705.37  |
| 2025-12-01T02:00:00+00:00 | 2025-12-01T03:00:00+00:00 | 99.88  | 100.05 | 99.86 | 100.00 | 1150.18 |
| … | … | … | … | … | … | … |


<a id="3.3"></a>
## STEP 4：自分のストラテジーを実装する

1. `trade/strategy/strategy.py` の `Strategy` クラスを置き換えます。
   * ストラテジーに新しい引数を渡したい場合は、`main.py` で他の引数と同じ形式で定義してください。
2. 上記と同様に、バックテストおよびリアルタイム・シグナル生成を実行します。


<a id="4"></a>
# 付録：引数の意味

このトレーディング・フレームワークで使用されるすべての引数は、`main.py` で定義されています。

| 引数                     | 型       | デフォルト値               | 説明                                                                                                                      |
| ---------------------- | ------- | -------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `--work_mode`          | `str`   | `"realtime"`         | フレームワークの動作モードを指定します。`"backtest"` は、既存の CSV データに対して履歴順にシグナル生成を行います。`"realtime"` は、新しく追加されたバーをトリガーとしてイベント駆動型のシグナル生成を行います。 |
| `--data_dir`           | `str`   | `data/asset_name`    | 単一アセットの OHLCV CSV ファイルを格納するディレクトリへのパスです。各 CSV は 1 日分のデータを表し、フレームワークが想定するスキーマおよびタイムスタンプ形式に従う必要があります。                     |
| `--signal_dir`         | `str`   | `signals/asset_name` | 生成されたシグナル CSV ファイルを書き込むディレクトリへのパスです。シグナルは日付単位で保存され、`data_dir` と同じディレクトリ構造を持ちます。                                         |
| `--num_past_timesteps` | `int`   | `100`                | 各タイムステップにおいてストラテジーに渡される固定長の過去データウィンドウの長さ（過去バー数）です。各ウィンドウにつきシグナルは 1 つだけ生成され、各シグナルは、対応する 1 つのウィンドウの情報のみに基づいて生成されます。                                                 |
| `--poll_interval`      | `float` | `0.5`                | リアルタイム・モードにおいて、新しく追加された OHLCV バーを検知するためのファイルシステムのポーリング間隔（秒）です。値を小さくすると応答性は向上しますが、チェック頻度が増加します。                          |


<a id="5"></a>
# 制限事項と範囲

<a id="5.0"></a>
## このフレームワークが行うこと

**バックテスト**

* 過去の OHLCV データを順に処理します。
* 各タイムステップにおいて、過去バーからなる固定長ウィンドウを構築します。
* 各ウィンドウにつき **1 つのシグナル**（`buy`、`sell`、`hold`）を生成します。
* 同梱されているストラテジーはプレースホルダーであり、**ランダムなシグナルのみ**を生成します。

**リアルタイム・シグナル生成**

* 流入する OHLCV データを監視します。
* 新しいバーが到着すると、直近の固定長ウィンドウを構築します。
* 新たに確定したバーのタイムステップに対して **1 つのシグナル**を生成します。



<a id="5.1"></a>
## このフレームワークが提供しないもの
このフレームワークは **トレーディング戦略そのものは実装していません**。
* 実際のアルファロジックは含まれていません。
* `trade/strategy/strategy.py` にて、ユーザー自身でストラテジーを実装する必要があります。

<a id="5.2"></a>
## 概念上の境界
<a id="5.2.0"></a>
### バックテストのスコープ
バックテスト・モードでは、次のことは **行いません**。
* 注文執行のシミュレーション
* ポジションの管理
* PnL（損益）の計算
* 手数料、スリッページ、リスクのモデル化

シグナル生成は、意図的に執行および評価から **分離** されています。
これらの要素は、独立したレイヤーとして実装されることを想定しています。


<a id="5.2.1"></a>
### シグナルの意味
* **シグナル**とは、**直近のバーのクローズ時点**で下される判断（`buy`、`sell`、`hold`）を指します。
* 各シグナルは、過去の OHLCV データからなる **固定長ウィンドウのみ**に基づいて生成されます。
* フレームワーク自体は、ポジションに関して **ステートレス**です。
* ポジションの状態やメモリが必要な場合は、**ストラテジー実装内**で処理する必要があります。


<a id="5.3"></a>
## 機能上の制限（MVP スコープ）

MVP として、このフレームワークは次の制約があります。

* **同時に扱えるアセットは 1 つのみ**です。
* シグナルは **そのアセット自身の OHLCV データのみ**から生成されます。
* すべてのシグナルに対して **固定長の過去データウィンドウ**を使用します。
